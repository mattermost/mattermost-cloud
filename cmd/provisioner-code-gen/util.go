// Copyright (c) 2015-present Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.
//

package main

import (
	"bytes"
	"fmt"
	"go/types"
	"io/ioutil"
	"os"
	"strings"

	"golang.org/x/tools/go/packages"

	"github.com/pkg/errors"
	"github.com/spf13/cobra"
)

func setupCodeBuffer(cmd *cobra.Command, pkgName string) (*bytes.Buffer, error) {
	code := &bytes.Buffer{}

	boilerplatePath, _ := cmd.Flags().GetString("boilerplate-file")
	if boilerplatePath != "" {
		file, err := ioutil.ReadFile(boilerplatePath)
		if err != nil {
			return nil, errors.Wrap(err, "failed to read boilerplate file")
		}

		code.Write(append(file, byte('\n')))
	}

	fmt.Fprintf(code, `// Code generated by generator, DO NOT EDIT.
package %s
`, pkgName)

	return code, nil
}

func printOutput(cmd *cobra.Command, code []byte, pkgName string) error {
	stdout, _ := cmd.Flags().GetBool("stdout")
	outFile, _ := cmd.Flags().GetString("out-file")

	if stdout && outFile == "" {
		_, err := cmd.OutOrStdout().Write(code)
		return err
	}

	if outFile == "" {
		outFile = fmt.Sprintf("%s_resource_impl_gen.go", pkgName)
	}

	return ioutil.WriteFile(outFile, code, os.ModePerm)
}

func loadTypes(c *cobra.Command) (*packages.Package, []string, []*types.Struct, error) {
	fullTypes, _ := c.Flags().GetStringSlice("type")
	if len(fullTypes) == 0 {
		return nil, nil, nil, fmt.Errorf("at least one type required")
	}

	pkgNames := make([]string, len(fullTypes))
	typeNames := make([]string, len(fullTypes))

	for i, t := range fullTypes {
		sourceTypePackage, sourceTypeName, err := splitSourceType(t)
		if err != nil {
			return nil, nil, nil, errors.Wrap(err, "invalid type")
		}
		pkgNames[i] = sourceTypePackage
		typeNames[i] = sourceTypeName
	}

	for i := 1; i < len(pkgNames); i++ {
		if pkgNames[i] != pkgNames[i-1] {
			return nil, nil, nil, fmt.Errorf("all types need to belong to the same package")
		}
	}

	pkg, err := loadPackage(pkgNames[0])
	if err != nil {
		return nil, nil, nil, errors.Wrap(err, "failed to load package")
	}

	structTypes := make([]*types.Struct, len(fullTypes))

	for i, tn := range typeNames {
		// Lookup the given source type name in the package declarations
		obj := pkg.Types.Scope().Lookup(tn)
		if obj == nil {
			return nil, nil, nil, fmt.Errorf("%s not found in declared types of %s", tn, pkg)
		}

		// We check if it is a declared type
		if _, ok := obj.(*types.TypeName); !ok {
			return nil, nil, nil, fmt.Errorf("%v is not a named type", obj)
		}
		// We expect the underlying type to be a struct
		structType, ok := obj.Type().Underlying().(*types.Struct)
		if !ok {
			return nil, nil, nil, fmt.Errorf("type %v is not a struct", obj)
		}
		structTypes[i] = structType
	}

	return pkg, typeNames, structTypes, nil
}

func loadPackage(path string) (*packages.Package, error) {
	cfg := &packages.Config{Mode: packages.NeedTypes | packages.NeedImports | packages.NeedName, Tests: true}
	pkgs, err := packages.Load(cfg, path)
	if err != nil {
		return nil, fmt.Errorf("loading packages for inspection: %v", err)
	}
	if packages.PrintErrors(pkgs) > 0 {
		return nil, fmt.Errorf("encountered package errors")
	}

	return pkgs[0], nil
}

func splitSourceType(sourceType string) (string, string, error) {
	idx := strings.LastIndexByte(sourceType, '.')
	if idx == -1 {
		return "", "", fmt.Errorf(`expected qualified type as "pkg/path.MyType"`)
	}
	sourceTypePackage := sourceType[0:idx]
	sourceTypeName := sourceType[idx+1:]
	return sourceTypePackage, sourceTypeName, nil
}
