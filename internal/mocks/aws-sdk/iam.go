// Copyright (c) Mattermost, Inc. All Rights Reserved.
// See LICENSE.txt for license information.
//
// Code generated by MockGen. DO NOT EDIT.
// Source: github.com/mattermost/mattermost-cloud/internal/tools/aws (interfaces: IAMAPI)

// Package mockawssdk is a generated GoMock package.
package mockawssdk

import (
	context "context"
	reflect "reflect"

	iam "github.com/aws/aws-sdk-go-v2/service/iam"
	gomock "github.com/golang/mock/gomock"
)

// MockIAMAPI is a mock of IAMAPI interface
type MockIAMAPI struct {
	ctrl     *gomock.Controller
	recorder *MockIAMAPIMockRecorder
}

// MockIAMAPIMockRecorder is the mock recorder for MockIAMAPI
type MockIAMAPIMockRecorder struct {
	mock *MockIAMAPI
}

// NewMockIAMAPI creates a new mock instance
func NewMockIAMAPI(ctrl *gomock.Controller) *MockIAMAPI {
	mock := &MockIAMAPI{ctrl: ctrl}
	mock.recorder = &MockIAMAPIMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockIAMAPI) EXPECT() *MockIAMAPIMockRecorder {
	return m.recorder
}

// AttachRolePolicy mocks base method
func (m *MockIAMAPI) AttachRolePolicy(arg0 context.Context, arg1 *iam.AttachRolePolicyInput, arg2 ...func(*iam.Options)) (*iam.AttachRolePolicyOutput, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "AttachRolePolicy", varargs...)
	ret0, _ := ret[0].(*iam.AttachRolePolicyOutput)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// AttachRolePolicy indicates an expected call of AttachRolePolicy
func (mr *MockIAMAPIMockRecorder) AttachRolePolicy(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AttachRolePolicy", reflect.TypeOf((*MockIAMAPI)(nil).AttachRolePolicy), varargs...)
}

// AttachUserPolicy mocks base method
func (m *MockIAMAPI) AttachUserPolicy(arg0 context.Context, arg1 *iam.AttachUserPolicyInput, arg2 ...func(*iam.Options)) (*iam.AttachUserPolicyOutput, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "AttachUserPolicy", varargs...)
	ret0, _ := ret[0].(*iam.AttachUserPolicyOutput)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// AttachUserPolicy indicates an expected call of AttachUserPolicy
func (mr *MockIAMAPIMockRecorder) AttachUserPolicy(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AttachUserPolicy", reflect.TypeOf((*MockIAMAPI)(nil).AttachUserPolicy), varargs...)
}

// CreateAccessKey mocks base method
func (m *MockIAMAPI) CreateAccessKey(arg0 context.Context, arg1 *iam.CreateAccessKeyInput, arg2 ...func(*iam.Options)) (*iam.CreateAccessKeyOutput, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "CreateAccessKey", varargs...)
	ret0, _ := ret[0].(*iam.CreateAccessKeyOutput)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// CreateAccessKey indicates an expected call of CreateAccessKey
func (mr *MockIAMAPIMockRecorder) CreateAccessKey(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateAccessKey", reflect.TypeOf((*MockIAMAPI)(nil).CreateAccessKey), varargs...)
}

// CreatePolicy mocks base method
func (m *MockIAMAPI) CreatePolicy(arg0 context.Context, arg1 *iam.CreatePolicyInput, arg2 ...func(*iam.Options)) (*iam.CreatePolicyOutput, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "CreatePolicy", varargs...)
	ret0, _ := ret[0].(*iam.CreatePolicyOutput)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// CreatePolicy indicates an expected call of CreatePolicy
func (mr *MockIAMAPIMockRecorder) CreatePolicy(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreatePolicy", reflect.TypeOf((*MockIAMAPI)(nil).CreatePolicy), varargs...)
}

// CreateUser mocks base method
func (m *MockIAMAPI) CreateUser(arg0 context.Context, arg1 *iam.CreateUserInput, arg2 ...func(*iam.Options)) (*iam.CreateUserOutput, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "CreateUser", varargs...)
	ret0, _ := ret[0].(*iam.CreateUserOutput)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// CreateUser indicates an expected call of CreateUser
func (mr *MockIAMAPIMockRecorder) CreateUser(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateUser", reflect.TypeOf((*MockIAMAPI)(nil).CreateUser), varargs...)
}

// DeleteAccessKey mocks base method
func (m *MockIAMAPI) DeleteAccessKey(arg0 context.Context, arg1 *iam.DeleteAccessKeyInput, arg2 ...func(*iam.Options)) (*iam.DeleteAccessKeyOutput, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "DeleteAccessKey", varargs...)
	ret0, _ := ret[0].(*iam.DeleteAccessKeyOutput)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// DeleteAccessKey indicates an expected call of DeleteAccessKey
func (mr *MockIAMAPIMockRecorder) DeleteAccessKey(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteAccessKey", reflect.TypeOf((*MockIAMAPI)(nil).DeleteAccessKey), varargs...)
}

// DeletePolicy mocks base method
func (m *MockIAMAPI) DeletePolicy(arg0 context.Context, arg1 *iam.DeletePolicyInput, arg2 ...func(*iam.Options)) (*iam.DeletePolicyOutput, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "DeletePolicy", varargs...)
	ret0, _ := ret[0].(*iam.DeletePolicyOutput)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// DeletePolicy indicates an expected call of DeletePolicy
func (mr *MockIAMAPIMockRecorder) DeletePolicy(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeletePolicy", reflect.TypeOf((*MockIAMAPI)(nil).DeletePolicy), varargs...)
}

// DeleteUser mocks base method
func (m *MockIAMAPI) DeleteUser(arg0 context.Context, arg1 *iam.DeleteUserInput, arg2 ...func(*iam.Options)) (*iam.DeleteUserOutput, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "DeleteUser", varargs...)
	ret0, _ := ret[0].(*iam.DeleteUserOutput)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// DeleteUser indicates an expected call of DeleteUser
func (mr *MockIAMAPIMockRecorder) DeleteUser(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteUser", reflect.TypeOf((*MockIAMAPI)(nil).DeleteUser), varargs...)
}

// DetachRolePolicy mocks base method
func (m *MockIAMAPI) DetachRolePolicy(arg0 context.Context, arg1 *iam.DetachRolePolicyInput, arg2 ...func(*iam.Options)) (*iam.DetachRolePolicyOutput, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "DetachRolePolicy", varargs...)
	ret0, _ := ret[0].(*iam.DetachRolePolicyOutput)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// DetachRolePolicy indicates an expected call of DetachRolePolicy
func (mr *MockIAMAPIMockRecorder) DetachRolePolicy(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DetachRolePolicy", reflect.TypeOf((*MockIAMAPI)(nil).DetachRolePolicy), varargs...)
}

// DetachUserPolicy mocks base method
func (m *MockIAMAPI) DetachUserPolicy(arg0 context.Context, arg1 *iam.DetachUserPolicyInput, arg2 ...func(*iam.Options)) (*iam.DetachUserPolicyOutput, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "DetachUserPolicy", varargs...)
	ret0, _ := ret[0].(*iam.DetachUserPolicyOutput)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// DetachUserPolicy indicates an expected call of DetachUserPolicy
func (mr *MockIAMAPIMockRecorder) DetachUserPolicy(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DetachUserPolicy", reflect.TypeOf((*MockIAMAPI)(nil).DetachUserPolicy), varargs...)
}

// GetPolicy mocks base method
func (m *MockIAMAPI) GetPolicy(arg0 context.Context, arg1 *iam.GetPolicyInput, arg2 ...func(*iam.Options)) (*iam.GetPolicyOutput, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetPolicy", varargs...)
	ret0, _ := ret[0].(*iam.GetPolicyOutput)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetPolicy indicates an expected call of GetPolicy
func (mr *MockIAMAPIMockRecorder) GetPolicy(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetPolicy", reflect.TypeOf((*MockIAMAPI)(nil).GetPolicy), varargs...)
}

// GetUser mocks base method
func (m *MockIAMAPI) GetUser(arg0 context.Context, arg1 *iam.GetUserInput, arg2 ...func(*iam.Options)) (*iam.GetUserOutput, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "GetUser", varargs...)
	ret0, _ := ret[0].(*iam.GetUserOutput)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetUser indicates an expected call of GetUser
func (mr *MockIAMAPIMockRecorder) GetUser(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetUser", reflect.TypeOf((*MockIAMAPI)(nil).GetUser), varargs...)
}

// ListAccessKeys mocks base method
func (m *MockIAMAPI) ListAccessKeys(arg0 context.Context, arg1 *iam.ListAccessKeysInput, arg2 ...func(*iam.Options)) (*iam.ListAccessKeysOutput, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ListAccessKeys", varargs...)
	ret0, _ := ret[0].(*iam.ListAccessKeysOutput)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ListAccessKeys indicates an expected call of ListAccessKeys
func (mr *MockIAMAPIMockRecorder) ListAccessKeys(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListAccessKeys", reflect.TypeOf((*MockIAMAPI)(nil).ListAccessKeys), varargs...)
}

// ListAccountAliases mocks base method
func (m *MockIAMAPI) ListAccountAliases(arg0 context.Context, arg1 *iam.ListAccountAliasesInput, arg2 ...func(*iam.Options)) (*iam.ListAccountAliasesOutput, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ListAccountAliases", varargs...)
	ret0, _ := ret[0].(*iam.ListAccountAliasesOutput)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ListAccountAliases indicates an expected call of ListAccountAliases
func (mr *MockIAMAPIMockRecorder) ListAccountAliases(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListAccountAliases", reflect.TypeOf((*MockIAMAPI)(nil).ListAccountAliases), varargs...)
}

// ListAttachedUserPolicies mocks base method
func (m *MockIAMAPI) ListAttachedUserPolicies(arg0 context.Context, arg1 *iam.ListAttachedUserPoliciesInput, arg2 ...func(*iam.Options)) (*iam.ListAttachedUserPoliciesOutput, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ListAttachedUserPolicies", varargs...)
	ret0, _ := ret[0].(*iam.ListAttachedUserPoliciesOutput)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ListAttachedUserPolicies indicates an expected call of ListAttachedUserPolicies
func (mr *MockIAMAPIMockRecorder) ListAttachedUserPolicies(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListAttachedUserPolicies", reflect.TypeOf((*MockIAMAPI)(nil).ListAttachedUserPolicies), varargs...)
}
